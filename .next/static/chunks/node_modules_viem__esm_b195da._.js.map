{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/viem/errors/ccip.ts"],"sourcesContent":["import type { Address } from 'abitype'\n\nimport type { Hex } from '../types/misc.js'\nimport { stringify } from '../utils/stringify.js'\n\nimport { BaseError } from './base.js'\nimport { getUrl } from './utils.js'\n\nexport type OffchainLookupErrorType = OffchainLookupError & {\n  name: 'OffchainLookupError'\n}\nexport class OffchainLookupError extends BaseError {\n  constructor({\n    callbackSelector,\n    cause,\n    data,\n    extraData,\n    sender,\n    urls,\n  }: {\n    callbackSelector: Hex\n    cause: BaseError\n    data: Hex\n    extraData: Hex\n    sender: Address\n    urls: readonly string[]\n  }) {\n    super(\n      cause.shortMessage ||\n        'An error occurred while fetching for an offchain result.',\n      {\n        cause,\n        metaMessages: [\n          ...(cause.metaMessages || []),\n          cause.metaMessages?.length ? '' : [],\n          'Offchain Gateway Call:',\n          urls && [\n            '  Gateway URL(s):',\n            ...urls.map((url) => `    ${getUrl(url)}`),\n          ],\n          `  Sender: ${sender}`,\n          `  Data: ${data}`,\n          `  Callback selector: ${callbackSelector}`,\n          `  Extra data: ${extraData}`,\n        ].flat(),\n        name: 'OffchainLookupError',\n      },\n    )\n  }\n}\n\nexport type OffchainLookupResponseMalformedErrorType =\n  OffchainLookupResponseMalformedError & {\n    name: 'OffchainLookupResponseMalformedError'\n  }\nexport class OffchainLookupResponseMalformedError extends BaseError {\n  constructor({ result, url }: { result: any; url: string }) {\n    super(\n      'Offchain gateway response is malformed. Response data must be a hex value.',\n      {\n        metaMessages: [\n          `Gateway URL: ${getUrl(url)}`,\n          `Response: ${stringify(result)}`,\n        ],\n        name: 'OffchainLookupResponseMalformedError',\n      },\n    )\n  }\n}\n\n/** @internal */\nexport type OffchainLookupSenderMismatchErrorType =\n  OffchainLookupSenderMismatchError & {\n    name: 'OffchainLookupSenderMismatchError'\n  }\nexport class OffchainLookupSenderMismatchError extends BaseError {\n  constructor({ sender, to }: { sender: Address; to: Address }) {\n    super(\n      'Reverted sender address does not match target contract address (`to`).',\n      {\n        metaMessages: [\n          `Contract address: ${to}`,\n          `OffchainLookup sender address: ${sender}`,\n        ],\n        name: 'OffchainLookupSenderMismatchError',\n      },\n    )\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;AAWM,MAAO,4BAA4B,iJAAA,CAAA,YAAS;IAChD,YAAY,EACV,gBAAgB,EAChB,KAAK,EACL,IAAI,EACJ,SAAS,EACT,MAAM,EACN,IAAI,EAQL,CAAA;QACC,KAAK,CACH,MAAM,YAAY,IAChB,4DACF;YACE;YACA,cAAc;mBACR,MAAM,YAAY,IAAI,EAAE;gBAC5B,MAAM,YAAY,EAAE,SAAS,KAAK,EAAE;gBACpC;gBACA,QAAQ;oBACN;uBACG,KAAK,GAAG,CAAC,CAAC,MAAQ,CAAA,IAAA,EAAO,CAAA,GAAA,kJAAA,CAAA,SAAM,AAAN,EAAO,KAAI,CAAE;iBAC1C;gBACD,CAAA,UAAA,EAAa,OAAM,CAAE;gBACrB,CAAA,QAAA,EAAW,KAAI,CAAE;gBACjB,CAAA,qBAAA,EAAwB,iBAAgB,CAAE;gBAC1C,CAAA,cAAA,EAAiB,UAAS,CAAE;aAC7B,CAAC,IAAI;YACN,MAAM;;IAGZ;;AAOI,MAAO,6CAA6C,iJAAA,CAAA,YAAS;IACjE,YAAY,EAAE,MAAM,EAAE,GAAG,EAAgC,CAAA;QACvD,KAAK,CACH,8EACA;YACE,cAAc;gBACZ,CAAA,aAAA,EAAgB,CAAA,GAAA,kJAAA,CAAA,SAAM,AAAN,EAAO,KAAI,CAAE;gBAC7B,CAAA,UAAA,EAAa,CAAA,GAAA,qJAAA,CAAA,YAAS,AAAT,EAAU,QAAO,CAAE;aACjC;YACD,MAAM;;IAGZ;;AAQI,MAAO,0CAA0C,iJAAA,CAAA,YAAS;IAC9D,YAAY,EAAE,MAAM,EAAE,EAAE,EAAoC,CAAA;QAC1D,KAAK,CACH,0EACA;YACE,cAAc;gBACZ,CAAA,kBAAA,EAAqB,GAAE,CAAE;gBACzB,CAAA,+BAAA,EAAkC,OAAM,CAAE;aAC3C;YACD,MAAM;;IAGZ"}},
    {"offset": {"line": 60, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 65, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/viem/utils/address/isAddressEqual.ts"],"sourcesContent":["import type { Address } from 'abitype'\n\nimport {\n  InvalidAddressError,\n  type InvalidAddressErrorType,\n} from '../../errors/address.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport { isAddress } from './isAddress.js'\n\nexport type IsAddressEqualReturnType = boolean\nexport type IsAddressEqualErrorType = InvalidAddressErrorType | ErrorType\n\nexport function isAddressEqual(a: Address, b: Address) {\n  if (!isAddress(a, { strict: false }))\n    throw new InvalidAddressError({ address: a })\n  if (!isAddress(b, { strict: false }))\n    throw new InvalidAddressError({ address: b })\n  return a.toLowerCase() === b.toLowerCase()\n}\n"],"names":[],"mappings":";;;;;;;;AAYM,SAAU,eAAe,CAAU,EAAE,CAAU;IACnD,IAAI,CAAC,CAAA,GAAA,gKAAA,CAAA,YAAS,AAAT,EAAU,GAAG;QAAE,QAAQ;IAAK,IAC/B,MAAM,IAAI,oJAAA,CAAA,sBAAmB,CAAC;QAAE,SAAS;IAAC;IAC5C,IAAI,CAAC,CAAA,GAAA,gKAAA,CAAA,YAAS,AAAT,EAAU,GAAG;QAAE,QAAQ;IAAK,IAC/B,MAAM,IAAI,oJAAA,CAAA,sBAAmB,CAAC;QAAE,SAAS;IAAC;IAC5C,OAAO,EAAE,WAAW,OAAO,EAAE,WAAW;AAC1C"}},
    {"offset": {"line": 86, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 91, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/viem/utils/ccip.ts"],"sourcesContent":["import type { Abi, Address } from 'abitype'\n\nimport { type CallParameters, call } from '../actions/public/call.js'\nimport type { Transport } from '../clients/transports/createTransport.js'\nimport type { BaseError } from '../errors/base.js'\nimport {\n  OffchainLookupError,\n  type OffchainLookupErrorType as OffchainLookupErrorType_,\n  OffchainLookupResponseMalformedError,\n  type OffchainLookupResponseMalformedErrorType,\n  OffchainLookupSenderMismatchError,\n} from '../errors/ccip.js'\nimport {\n  HttpRequestError,\n  type HttpRequestErrorType,\n} from '../errors/request.js'\nimport type { Chain } from '../types/chain.js'\nimport type { Hex } from '../types/misc.js'\n\nimport type { Client } from '../clients/createClient.js'\nimport type { ErrorType } from '../errors/utils.js'\nimport { decodeErrorResult } from './abi/decodeErrorResult.js'\nimport { encodeAbiParameters } from './abi/encodeAbiParameters.js'\nimport { isAddressEqual } from './address/isAddressEqual.js'\nimport { concat } from './data/concat.js'\nimport { isHex } from './data/isHex.js'\nimport { stringify } from './stringify.js'\n\nexport const offchainLookupSignature = '0x556f1830'\nexport const offchainLookupAbiItem = {\n  name: 'OffchainLookup',\n  type: 'error',\n  inputs: [\n    {\n      name: 'sender',\n      type: 'address',\n    },\n    {\n      name: 'urls',\n      type: 'string[]',\n    },\n    {\n      name: 'callData',\n      type: 'bytes',\n    },\n    {\n      name: 'callbackFunction',\n      type: 'bytes4',\n    },\n    {\n      name: 'extraData',\n      type: 'bytes',\n    },\n  ],\n} as const satisfies Abi[number]\n\nexport type OffchainLookupErrorType = OffchainLookupErrorType_ | ErrorType\n\nexport async function offchainLookup<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  {\n    blockNumber,\n    blockTag,\n    data,\n    to,\n  }: Pick<CallParameters, 'blockNumber' | 'blockTag'> & {\n    data: Hex\n    to: Address\n  },\n): Promise<Hex> {\n  const { args } = decodeErrorResult({\n    data,\n    abi: [offchainLookupAbiItem],\n  })\n  const [sender, urls, callData, callbackSelector, extraData] = args\n\n  const { ccipRead } = client\n  const ccipRequest_ =\n    ccipRead && typeof ccipRead?.request === 'function'\n      ? ccipRead.request\n      : ccipRequest\n\n  try {\n    if (!isAddressEqual(to, sender))\n      throw new OffchainLookupSenderMismatchError({ sender, to })\n\n    const result = await ccipRequest_({ data: callData, sender, urls })\n\n    const { data: data_ } = await call(client, {\n      blockNumber,\n      blockTag,\n      data: concat([\n        callbackSelector,\n        encodeAbiParameters(\n          [{ type: 'bytes' }, { type: 'bytes' }],\n          [result, extraData],\n        ),\n      ]),\n      to,\n    } as CallParameters)\n\n    return data_!\n  } catch (err) {\n    throw new OffchainLookupError({\n      callbackSelector,\n      cause: err as BaseError,\n      data,\n      extraData,\n      sender,\n      urls,\n    })\n  }\n}\n\nexport type CcipRequestParameters = {\n  data: Hex\n  sender: Address\n  urls: readonly string[]\n}\n\nexport type CcipRequestReturnType = Hex\n\nexport type CcipRequestErrorType =\n  | HttpRequestErrorType\n  | OffchainLookupResponseMalformedErrorType\n  | ErrorType\n\nexport async function ccipRequest({\n  data,\n  sender,\n  urls,\n}: CcipRequestParameters): Promise<CcipRequestReturnType> {\n  let error = new Error('An unknown error occurred.')\n\n  for (let i = 0; i < urls.length; i++) {\n    const url = urls[i]\n    const method = url.includes('{data}') ? 'GET' : 'POST'\n    const body = method === 'POST' ? { data, sender } : undefined\n    const headers =\n      method === 'POST' ? { 'Content-Type': 'application/json' } : {}\n\n    try {\n      const response = await fetch(\n        url.replace('{sender}', sender).replace('{data}', data),\n        {\n          body: JSON.stringify(body),\n          headers,\n          method,\n        },\n      )\n\n      let result: any\n      if (\n        response.headers.get('Content-Type')?.startsWith('application/json')\n      ) {\n        result = (await response.json()).data\n      } else {\n        result = (await response.text()) as any\n      }\n\n      if (!response.ok) {\n        error = new HttpRequestError({\n          body,\n          details: result?.error\n            ? stringify(result.error)\n            : response.statusText,\n          headers: response.headers,\n          status: response.status,\n          url,\n        })\n        continue\n      }\n\n      if (!isHex(result)) {\n        error = new OffchainLookupResponseMalformedError({\n          result,\n          url,\n        })\n        continue\n      }\n\n      return result\n    } catch (err) {\n      error = new HttpRequestError({\n        body,\n        details: (err as Error).message,\n        url,\n      })\n    }\n  }\n\n  throw error\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 246, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}